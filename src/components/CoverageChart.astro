---
interface DataRow {
  char_count: number;
}

export interface Props {
  class?: string;
  takeFirst: number;
  datasets: {
    [key: string]: {
      data: DataRow[];
      color: string;
    };
  };
  width: number;
  height: number;
  margin: number;
  scaleLines: {
    x: number;
    y: number;
  };
  fontSize?: number;
  dashArray?: string;
}

const {
  class: className,
  datasets,
  takeFirst,
  width,
  height,
  margin,
  scaleLines,
  fontSize = 8,
  dashArray = '5,2',
} = Astro.props;

function coverage(data: DataRow[], takeFirst: number): number[] {
  const total = +data[0].char_count;

  let accumulator = 0;
  return data.slice(1, 1 + takeFirst).map(({ char_count }) => {
    accumulator += +char_count;
    return accumulator / total;
  });
}

function coverageLine(
  coverage: number[],
  width: number,
  height: number,
  margin: number,
): string {
  const fromX = margin;
  const toX = width - margin;
  const rangeX = Math.abs(toX - fromX);
  const stepX = rangeX / coverage.length;

  const fromY = margin;
  const toY = height - margin;
  const rangeY = Math.abs(toY - fromY);

  return coverage
    .map((cov, index) => {
      const op = index === 0 ? 'M' : 'L';
      const x = fromX + index * stepX;
      const y = toY - rangeY * cov;
      return `${op} ${x} ${y}`;
    })
    .join(' ');
}

const axisColor = 'rgb(23 23 23)'; // text-neutral-900

const xAxisPath = `M ${margin} ${height - margin} L ${width - margin} ${
  height - margin
}`;
const yAxisPath = `M ${margin} ${height - margin} L ${margin} ${margin}`;

const tickSize = margin / 10;

const bgScaleLineOpacity = 0.2;
const bgScaleLineWidth = 0.75;

function range(start: number, end: number, step: number): number[] {
  const result = [];
  for (let n = start; n <= end; n += step) {
    result.push(n);
  }
  return result;
}
---

<div class={className}>
  <svg
    width={width}
    height={height}
    viewBox={[0, 0, width, height].join(' ')}
    style="width: 100%; height: auto; height: intrinsic;"
  >
    {
      range(0, takeFirst, scaleLines.x).map((xVal) => {
        const fromX = margin;
        const toX = width - margin;
        const rangeX = Math.abs(toX - fromX);
        const x = fromX + rangeX * (xVal / takeFirst);
        const bgLinePath = `M ${x} ${height - margin} L ${x} ${margin}`;
        const tickPath = `M ${x} ${height - margin} L ${x} ${
          height - margin + tickSize
        }`;
        return (
          <>
            <path
              d={bgLinePath}
              stroke={axisColor}
              stroke-width={bgScaleLineWidth}
              stroke-opacity={bgScaleLineOpacity}
              stroke-dasharray={dashArray}
              fill="none"
            />
            <path
              d={tickPath}
              stroke={axisColor}
              stroke-width={1}
              stroke-opacity={1}
              fill="none"
            />
            <text
              x={x}
              y={height - margin + fontSize + tickSize}
              font-size={fontSize}
              font-color={axisColor}
              text-anchor="middle"
            >
              {xVal}
            </text>
          </>
        );
      })
    }
    {
      range(0, 1, scaleLines.y).map((yVal) => {
        const fromY = height - margin;
        const toY = margin;
        const rangeY = Math.abs(toY - fromY);
        const y = fromY - rangeY * yVal;
        const bgLinePath = `M ${margin} ${y} L ${width - margin} ${y}`;
        const tickPath = `M ${margin} ${y} L ${margin - tickSize} ${y}`;
        const yPercent = Math.round(yVal * 100);
        return (
          <>
            <path
              d={bgLinePath}
              stroke={axisColor}
              stroke-width={bgScaleLineWidth}
              stroke-opacity={bgScaleLineOpacity}
              stroke-dasharray={dashArray}
              fill="none"
            />
            <path
              d={tickPath}
              stroke={axisColor}
              stroke-width={1}
              stroke-opacity={1}
              fill="none"
            />
            <text
              x={margin - tickSize}
              y={y + fontSize * 0.4}
              font-size={fontSize}
              font-color={axisColor}
              text-anchor="end"
            >
              {yPercent}%
            </text>
          </>
        );
      })
    }
    <text
      font-size={fontSize}
      font-color={axisColor}
      x={margin}
      y={margin - fontSize * 0.5}
    >
      Coverage of corpus, %
    </text>
    <text
      font-size={fontSize}
      font-color={axisColor}
      x={width / 2}
      y={height - margin + tickSize + fontSize * 2.5}
      text-anchor="middle"
    >
      # of first most frequent characters
    </text>
    <path d={xAxisPath} stroke={axisColor} stroke-width={1} fill="none"></path>
    <path d={yAxisPath} stroke={axisColor} stroke-width={1} fill="none"></path>
    {
      Object.keys(datasets).map((datasetKey) => (
        <path
          d={coverageLine(
            coverage(datasets[datasetKey].data, takeFirst),
            width,
            height,
            margin,
          )}
          stroke={datasets[datasetKey].color}
          stroke-width={1.5}
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-opacity={1}
          fill="none"
        />
      ))
    }
  </svg>
  <div class="flex flex-wrap gap-x-4 gap-y-2 justify-center">
    {
      Object.keys(datasets)
        .reverse()
        .map((datasetKey) => (
          <div class="flex gap-1">
            <div
              class="font-bold"
              style={{ color: datasets[datasetKey].color }}
            >
              &mdash;
            </div>
            <div>{datasetKey}</div>
          </div>
        ))
    }
  </div>
</div>
